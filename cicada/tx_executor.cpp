#include "tx_executor.h"
#include "../common/atomic_wrapper.h"
#include "../common/step.h"
#include "../common/debug.h"
#include "tuple.h"
#include <cstring>


using std::memory_order_acquire;
using std::memory_order_acq_rel;

TXExecutor::TXExecutor(
  uint8_t threadId_, Result *result_)
: result(result_), threadId(threadId_)
{
  while(MinWts.load(memory_order_acquire) == 0){
    ; // wait to initialize MinWts(wait for store at main();)
  }
  /**
   * """
   * (thread.wts) stores the timestamp generated by the above procedure.
   * (thread.rts) stores min_wts minus 1.
   *
   * threadとtxのtsの違いに気を付けて！
   * """
   */
  wts.generateTimeStampFirst(threadId);
  rts = MinWts.load(memory_order_acquire) - 1;

  // thread.wtsはtxのコンストラクタで生成するが、管理はglobal array
  storeRelease(ThreadWtsArray[threadId].body, wts.body);
  unsigned int expected, desired;
  expected = FirstAllocateTimestamp.load(memory_order_acquire);
  for(;;){
    desired = expected + 1;
    // ほかのthreadとtsがかぶらないようにするため？？？？
    if(FirstAllocateTimestamp.compare_exchange_weak(expected, desired, memory_order_acq_rel)){
      break;
    }
  }

  readSet.reserve(MAX_OPERATIONS);
  writeSet.reserve(MAX_OPERATIONS);
  steps.reserve(MAX_OPERATIONS);

  // GC用？
  for(size_t i = 0; i < PRE_RESERVE_VERSION; ++i){
    reuseVersionFromGC.emplace_back(new Version());
  }

  genStringRepeatedNumber(writeValue, VALUE_SIZE, threadId);

  start = rdtscp();
  GCStart = start;

}

TXExecutor::~TXExecutor() {
  for(auto version: reuseVersionFromGC){
    if(version->status == Unused){
      delete version;
    }
  }
  reuseVersionFromGC.clear();
  readSet.clear();
  writeSet.clear();
  GCQueue.clear();
  steps.clear();
}

void TXExecutor::abort() {
  ERR;
}

void TXExecutor::begin() {
  this->status = InFlight;
  this->wts.generateTimeStamp(threadId);
  storeRelease(ThreadWtsArray[threadId].body, this->wts.body);
  this->rts = MinWts.load(std::memory_order_acquire);
  storeRelease(ThreadRtsArray[threadId].body, this->rts);

  // TODO: one-sided synchronization
}

void TXExecutor::read(const uint64_t &key) {
  /**
   * avoid re-read
   */
  if(searchWriteSet(key) || searchReadSet(key)) return;

  Tuple *tuple = &Table[key];
  Version *ver, *laterVer;
  laterVer = nullptr;

  /**
   * """
   * A read-write transaction uses (thread.wts) as its timestamp.
   * A read-only transaction uses (thread.rts) instead, and
   * does not track or validate the read set.
   * """
   *
   * c.f. §3.1
   */
  uint64_t thread_ts;
  if(this->steps.begin()->readOnly){
    thread_ts = rts;
  }else{
    thread_ts = wts.body;
  }

  /**
   * """
   * A transaction with a timestamp (tx.ts) accessing a record
   * scans the version list of the record from latest
   * to earliest order to find a version to use. It ignores
   * any later version if (v.wts) > (tx.ts).
   * Otherwise, it checks (v.status). For PENDING, it spin-waits
   * until the status is changed. For ABORTED, it ignores this version
   * and proceeds to an earlier version. For COMMITTED, it stops
   * searching and chooses the version; we refer to this version
   * as the version visible to the transaction.
   * """
   *
   * cf. §3.2
   */
  ver = tuple->loadAcquireLatest();
  while(ver->loadAcquireWts() > thread_ts){
    laterVer = ver;
    ver = ver->loadAcquireNext();
  }
  while(ver->status.load(memory_order_acquire) != Committed){
    // visibleに到達してからpendingでwaitする
    while(ver->status.load(memory_order_acquire) == Pending){
    }

    if(ver->status.load(memory_order_acquire) == Aborted){
      ver = ver->loadAcquireNext();
    }
  }

  memcpy(returnValue, ver->value, VALUE_SIZE);

  /**
   * If not read-only TX, track or validate readSet
   */
   if(!this->steps.begin()->readOnly){
     readSet.emplace_back(key, tuple, laterVer, ver);
   }
}

void TXExecutor::write(const uint64_t &key) {
  if(searchWriteSet(key)) return;

  Tuple *tuple;
  // RMWかどうか、のフラグ
  bool rmw;
  rmw = false;
  ReadElement<Tuple> *re;
  re = searchReadSet(key);
  if(re){
    // RMW用の処理
    rmw = true;
    tuple = re->recordPtr;
  }else{
    tuple = &Table[key];
  }

  Version *later_ver, *ver;
  later_ver = nullptr;
  ver = tuple->loadAcquireLatest();

  if(rmw){
    // Early abortのため、RMWにはwrite latest version only ruleを適用。
    // §3.2 の最後
    if(ver->wts.load(memory_order_acquire) > wts.body){
      status = Abort;
      return;
    }
  }else{
    while (ver->wts.load(memory_order_acquire) > wts.body){
      later_ver = ver;
      ver = ver->loadAcquireNext();
    }
  }

  if((ver->loadAcquireRts() > wts.body)
    && (ver->loadAcquireStatus() == Committed)){
    // early abort
    status = Abort;
    return;
  }

  auto new_ver = new Version(0, wts.body);
  writeSet.emplace_back(key, tuple, later_ver, new_ver, rmw);
}

bool TXExecutor::validation() {
  ERR;
  return false;
}

void TXExecutor::writePhase() {
  ERR;
}

ReadElement<Tuple> *TXExecutor::searchReadSet(uint64_t key) {
  for(auto &op: readSet){
    if(op.key == key) return &op;
  }
  return nullptr;
}

WriteElement<Tuple> *TXExecutor::searchWriteSet(uint64_t key) {
  for(auto &op: writeSet){
    if(op.key == key) return &op;
  }
  return nullptr;
}

void TXExecutor::earlyAbort() {

}

void TXExecutor::writeSetClean() {
  for(auto it = writeSet.begin(); it != writeSet.end(); ++it){

  }
}
